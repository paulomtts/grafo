{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Grafo","text":"<p>Grafo is a simple yet powerful Python library for building and executing asynchronous task trees. It enables you to orchestrate complex workflows with automatic concurrency management, state passing, and dynamic tree modification.</p>"},{"location":"#what-is-grafo","title":"What is Grafo?","text":"<p>Grafo allows you to organize asynchronous tasks (coroutines) into tree structures where nodes represent units of work. The library handles execution orchestration with one key principle:</p> <p>A node can only start executing once all its parents have finished running.</p> <p>This constraint enables powerful patterns like:</p> <ul> <li>Pipeline processing with dependencies</li> <li>Parallel execution of independent branches</li> <li>Hierarchical task decomposition</li> <li>Dynamic workflow modification during runtime</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#automatic-worker-management","title":"Automatic Worker Management","text":"<p>The library dynamically scales the number of concurrent workers based on queue load. You don't need to manually manage thread pools or worker counts.</p>"},{"location":"#flexible-tree-structures","title":"Flexible Tree Structures","text":"<p>Trees can have any shape:</p> <ul> <li>Single or multiple root nodes</li> <li>Linear chains or complex DAGs</li> <li>Dynamic modifications during runtime</li> </ul>"},{"location":"#state-passing","title":"State Passing","text":"<p>Pass data between nodes in two ways:</p> <ul> <li>Manual forwarding: Use lambda functions for dynamic evaluation</li> <li>Automatic forwarding: Specify output forwarding when connecting nodes</li> </ul>"},{"location":"#intermediate-results","title":"Intermediate Results","text":"<p>Yielding coroutines produce <code>Chunk</code> objects that wrap intermediate results, allowing you to stream progress updates.</p>"},{"location":"#type-safety","title":"Type Safety","text":"<p>Use Python generics to validate node outputs at runtime.</p>"},{"location":"#event-callbacks","title":"Event Callbacks","text":"<p>Hook into node lifecycle events for monitoring, logging, or custom behaviors.</p>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Grafo follows three core principles:</p> <ol> <li>Follow established nomenclature: a Node is a Node - precise terminology</li> <li>Syntax sugar is sweet in moderation: minimal magic, explicit API</li> <li>Give the programmer granular control: fine-grained customization options</li> </ol>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import asyncio\nfrom grafo import Node, TreeExecutor\n\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"data\"\n\nasync def process_data(data: str):\n    await asyncio.sleep(1)\n    return f\"processed_{data}\"\n\nasync def save_result(result: str):\n    await asyncio.sleep(1)\n    print(f\"Saved: {result}\")\n    return \"done\"\n\nasync def main():\n    # Create nodes\n    fetcher = Node(coroutine=fetch_data, uuid=\"fetcher\")\n    processor = Node(coroutine=process_data, uuid=\"processor\")\n    saver = Node(coroutine=save_result, uuid=\"saver\")\n\n    # Build tree with automatic forwarding\n    await fetcher.connect(processor, forward_as=\"data\")\n    await processor.connect(saver, forward_as=\"result\")\n\n    # Execute\n    executor = TreeExecutor(uuid=\"Pipeline\", roots=[fetcher])\n    await executor.run()\n\nasyncio.run(main())\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Get Grafo installed</li> <li>Quick Start - Build your first tree</li> <li>Core Concepts - Understand the fundamentals</li> <li>User Guide - Learn all the features</li> </ul>"},{"location":"#license","title":"License","text":"<p>Grafo is released under the MIT License.</p>"},{"location":"api-reference/chunk/","title":"Chunk API Reference","text":"<p>Complete API documentation for the <code>Chunk</code> dataclass.</p>"},{"location":"api-reference/chunk/#class-definition","title":"Class Definition","text":"<pre><code>@dataclass(frozen=True)\nclass Chunk(Generic[C]):\n    \"\"\"\n    Wrapper for intermediate results from async generator nodes.\n\n    A frozen (immutable) dataclass that wraps yielded values with metadata.\n\n    Type Parameters:\n        C: The type of the wrapped output value\n\n    Attributes:\n        uuid: UUID of the source node that yielded this chunk\n        output: The yielded value\n    \"\"\"\n</code></pre>"},{"location":"api-reference/chunk/#attributes","title":"Attributes","text":""},{"location":"api-reference/chunk/#uuid","title":"uuid","text":"<pre><code>uuid: str\n</code></pre> <p>The UUID of the node that produced this chunk.</p> <p>Example: <pre><code>async for item in executor.yielding():\n    if isinstance(item, Chunk):\n        print(f\"Chunk from node: {item.uuid}\")\n</code></pre></p>"},{"location":"api-reference/chunk/#output","title":"output","text":"<pre><code>output: C\n</code></pre> <p>The yielded value from the node's async generator.</p> <p>Example: <pre><code>async for item in executor.yielding():\n    if isinstance(item, Chunk):\n        value = item.output\n        print(f\"Value: {value}\")\n</code></pre></p>"},{"location":"api-reference/chunk/#usage","title":"Usage","text":""},{"location":"api-reference/chunk/#creating-chunks","title":"Creating Chunks","text":"<p>Chunks are created automatically by Grafo when nodes yield values. You typically don't create them manually:</p> <pre><code>async def yielding_task():\n    for i in range(5):\n        yield f\"item_{i}\"  # Automatically wrapped in Chunk\n\nnode = Node(coroutine=yielding_task, uuid=\"producer\")\n</code></pre>"},{"location":"api-reference/chunk/#receiving-chunks","title":"Receiving Chunks","text":"<p>Chunks are received when using <code>TreeExecutor.yielding()</code>:</p> <pre><code>executor = TreeExecutor(roots=[node])\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        # item is a Chunk object\n        source = item.uuid\n        value = item.output\n</code></pre>"},{"location":"api-reference/chunk/#type-checking","title":"Type Checking","text":"<p>Use <code>isinstance()</code> to distinguish chunks from nodes:</p> <pre><code>async for item in executor.yielding():\n    if isinstance(item, Chunk):\n        print(f\"Chunk: {item.output}\")\n    elif isinstance(item, Node):\n        print(f\"Node completed: {item.uuid}\")\n</code></pre>"},{"location":"api-reference/chunk/#type-parameters","title":"Type Parameters","text":""},{"location":"api-reference/chunk/#generic-chunk-types","title":"Generic Chunk Types","text":"<p>Chunks preserve type information:</p> <pre><code>async def yield_strings():\n    yield \"first\"\n    yield \"second\"\n\nasync def yield_numbers():\n    yield 1\n    yield 2\n\nstring_node = Node[str](coroutine=yield_strings, uuid=\"strings\")\nnumber_node = Node[int](coroutine=yield_numbers, uuid=\"numbers\")\n\nexecutor = TreeExecutor(roots=[string_node, number_node])\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        # item.output type is preserved\n        if item.uuid == \"strings\":\n            # item is Chunk[str]\n            text: str = item.output\n        elif item.uuid == \"numbers\":\n            # item is Chunk[int]\n            number: int = item.output\n</code></pre>"},{"location":"api-reference/chunk/#immutability","title":"Immutability","text":"<p>Chunks are frozen dataclasses and cannot be modified:</p> <pre><code>async for item in executor.yielding():\n    if isinstance(item, Chunk):\n        # This will raise an error\n        try:\n            item.output = \"new value\"\n        except AttributeError:\n            print(\"Chunks are immutable\")\n</code></pre>"},{"location":"api-reference/chunk/#comparison-and-equality","title":"Comparison and Equality","text":"<p>Chunks can be compared based on their attributes:</p> <pre><code>chunk1 = Chunk(uuid=\"node_1\", output=\"value\")\nchunk2 = Chunk(uuid=\"node_1\", output=\"value\")\nchunk3 = Chunk(uuid=\"node_2\", output=\"value\")\n\nassert chunk1 == chunk2  # Same uuid and output\nassert chunk1 != chunk3  # Different uuid\n</code></pre>"},{"location":"api-reference/chunk/#common-patterns","title":"Common Patterns","text":""},{"location":"api-reference/chunk/#collecting-chunks-by-source","title":"Collecting Chunks by Source","text":"<pre><code>from collections import defaultdict\n\nchunks_by_node = defaultdict(list)\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        chunks_by_node[item.uuid].append(item.output)\n\n# Process chunks by source\nfor node_uuid, values in chunks_by_node.items():\n    print(f\"{node_uuid} produced {len(values)} chunks\")\n</code></pre>"},{"location":"api-reference/chunk/#processing-chunks-in-real-time","title":"Processing Chunks in Real-Time","text":"<pre><code>async for item in executor.yielding():\n    if isinstance(item, Chunk):\n        # Process immediately\n        await process_value(item.output)\n\n        # Log progress\n        logger.info(f\"Processed chunk from {item.uuid}\")\n\n        # Update UI\n        ui.update_progress(item.uuid, item.output)\n</code></pre>"},{"location":"api-reference/chunk/#filtering-chunks","title":"Filtering Chunks","text":"<pre><code>async for item in executor.yielding():\n    if isinstance(item, Chunk):\n        # Only process chunks from specific nodes\n        if item.uuid in [\"important_node_1\", \"important_node_2\"]:\n            await handle_important_chunk(item.output)\n\n        # Only process chunks with specific values\n        if item.output.startswith(\"ERROR\"):\n            await handle_error(item.output)\n</code></pre>"},{"location":"api-reference/chunk/#aggregating-chunks","title":"Aggregating Chunks","text":"<pre><code>all_chunks = []\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        all_chunks.append(item)\n\n# Aggregate by node\nfrom itertools import groupby\n\nall_chunks.sort(key=lambda c: c.uuid)\nfor node_uuid, chunks in groupby(all_chunks, key=lambda c: c.uuid):\n    outputs = [c.output for c in chunks]\n    print(f\"{node_uuid}: {len(outputs)} chunks\")\n</code></pre>"},{"location":"api-reference/chunk/#progress-tracking","title":"Progress Tracking","text":"<pre><code>from datetime import datetime\n\nprogress = {}\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        if item.uuid not in progress:\n            progress[item.uuid] = {\n                \"start\": datetime.now(),\n                \"chunks\": 0\n            }\n\n        progress[item.uuid][\"chunks\"] += 1\n        progress[item.uuid][\"last_update\"] = datetime.now()\n\n        # Display progress\n        p = progress[item.uuid]\n        elapsed = (p[\"last_update\"] - p[\"start\"]).total_seconds()\n        print(f\"{item.uuid}: {p['chunks']} chunks in {elapsed:.1f}s\")\n</code></pre>"},{"location":"api-reference/chunk/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom grafo import Node, TreeExecutor, Chunk\n\nasync def download_file(url: str, filename: str):\n    \"\"\"Simulate file download with progress updates.\"\"\"\n    total_chunks = 10\n    for i in range(total_chunks):\n        await asyncio.sleep(0.5)\n        progress = (i + 1) / total_chunks * 100\n        yield {\n            \"filename\": filename,\n            \"chunk\": i + 1,\n            \"total\": total_chunks,\n            \"progress\": progress\n        }\n\nasync def main():\n    # Create download tasks\n    downloads = [\n        Node[dict](\n            coroutine=download_file,\n            uuid=f\"download_{i}\",\n            kwargs=dict(\n                url=f\"https://example.com/file{i}.zip\",\n                filename=f\"file{i}.zip\"\n            )\n        )\n        for i in range(3)\n    ]\n\n    executor = TreeExecutor(uuid=\"Downloads\", roots=downloads)\n\n    # Track progress for each download\n    progress_bars = {}\n\n    async for item in executor.yielding():\n        if isinstance(item, Chunk):\n            data = item.output\n            filename = data[\"filename\"]\n\n            # Update progress\n            progress_bars[filename] = data[\"progress\"]\n\n            # Display\n            bar = \"\u2588\" * int(data[\"progress\"] // 5) + \"\u2591\" * (20 - int(data[\"progress\"] // 5))\n            print(f\"{filename}: [{bar}] {data['progress']:.0f}% ({data['chunk']}/{data['total']})\")\n\n        elif isinstance(item, Node):\n            print(f\"\u2713 {item.uuid} completed\")\n\n    print(f\"\\nAll downloads complete!\")\n\nasyncio.run(main())\n</code></pre> <p>Output: <pre><code>file0.zip: [\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 10% (1/10)\nfile1.zip: [\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 10% (1/10)\nfile2.zip: [\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 10% (1/10)\nfile0.zip: [\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 20% (2/10)\n...\nfile0.zip: [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] 100% (10/10)\n\u2713 download_0 completed\nfile1.zip: [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] 100% (10/10)\n\u2713 download_1 completed\nfile2.zip: [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] 100% (10/10)\n\u2713 download_2 completed\n\nAll downloads complete!\n</code></pre></p>"},{"location":"api-reference/chunk/#type-validation","title":"Type Validation","text":"<p>Chunks respect type validation from their source nodes:</p> <pre><code>async def typed_yielder():\n    yield \"string1\"\n    yield \"string2\"\n    yield 123  # Wrong type!\n\nnode = Node[str](coroutine=typed_yielder, uuid=\"typed\")\n\ntry:\n    async for item in TreeExecutor(roots=[node]).yielding():\n        if isinstance(item, Chunk):\n            print(item.output)\nexcept Exception as e:\n    print(f\"Type error: {e}\")\n    # MismatchChunkType raised on third yield\n</code></pre>"},{"location":"api-reference/chunk/#see-also","title":"See Also","text":"<ul> <li>Node - Node API for creating yielding coroutines</li> <li>TreeExecutor - Executor API for receiving chunks</li> <li>Yielding Results - Guide to using chunks</li> </ul>"},{"location":"api-reference/exceptions/","title":"Exceptions API Reference","text":"<p>Complete documentation for Grafo's custom exceptions.</p>"},{"location":"api-reference/exceptions/#overview","title":"Overview","text":"<p>Grafo defines several custom exceptions for specific error conditions:</p> <ul> <li><code>SafeExecutionError</code> - Node modified during execution</li> <li><code>NotAsyncCallableError</code> - Wrong coroutine type for method</li> <li><code>ForwardingOverrideError</code> - Forwarding conflicts with existing kwargs</li> <li><code>MismatchChunkType</code> - Type validation failure</li> </ul>"},{"location":"api-reference/exceptions/#safeexecutionerror","title":"SafeExecutionError","text":""},{"location":"api-reference/exceptions/#description","title":"Description","text":"<p>Raised when attempting to modify a node that is currently executing.</p> <p>This prevents race conditions and ensures tree structure integrity during execution.</p>"},{"location":"api-reference/exceptions/#signature","title":"Signature","text":"<pre><code>class SafeExecutionError(Exception):\n    \"\"\"Raised when a node is modified during its execution.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#when-raised","title":"When Raised","text":"<ul> <li>Connecting a child to a running node</li> <li>Disconnecting a child from a running node</li> <li>Redirecting children of a running node</li> </ul>"},{"location":"api-reference/exceptions/#example","title":"Example","text":"<pre><code>import asyncio\nfrom grafo import Node, TreeExecutor\nfrom grafo.errors import SafeExecutionError\n\nasync def long_task():\n    await asyncio.sleep(10)\n    return \"done\"\n\nasync def modify_during_execution():\n    node = Node(coroutine=long_task, uuid=\"long\")\n    executor = TreeExecutor(roots=[node])\n\n    # Start execution\n    run_task = asyncio.create_task(executor.run())\n\n    # Try to modify while running\n    try:\n        new_child = Node(coroutine=some_task, uuid=\"child\")\n        await node.connect(new_child)\n    except SafeExecutionError as e:\n        print(f\"Cannot modify running node: {e}\")\n\n    await run_task\n\nasyncio.run(modify_during_execution())\n</code></pre>"},{"location":"api-reference/exceptions/#prevention","title":"Prevention","text":"<p>Wait for execution to complete before modifying:</p> <pre><code>await executor.run()  # Wait for completion\n\n# Now safe to modify\nawait node.connect(new_child)\n</code></pre>"},{"location":"api-reference/exceptions/#notasynccallableerror","title":"NotAsyncCallableError","text":""},{"location":"api-reference/exceptions/#description_1","title":"Description","text":"<p>Raised when calling a method that expects a specific coroutine type, but the node's coroutine doesn't match.</p>"},{"location":"api-reference/exceptions/#signature_1","title":"Signature","text":"<pre><code>class NotAsyncCallableError(Exception):\n    \"\"\"Raised when a method is called on the wrong coroutine type.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#when-raised_1","title":"When Raised","text":"<ul> <li>Calling <code>run_yielding()</code> on a node with a regular async function (not a generator)</li> <li>Calling <code>run()</code> on a node with an async generator (should use <code>run_yielding()</code>)</li> </ul>"},{"location":"api-reference/exceptions/#example_1","title":"Example","text":"<pre><code>from grafo import Node\nfrom grafo.errors import NotAsyncCallableError\n\nasync def regular_coroutine():\n    return \"result\"  # Not a generator\n\nnode = Node(coroutine=regular_coroutine, uuid=\"regular\")\n\ntry:\n    # Trying to use yielding method on regular coroutine\n    async for chunk in node.run_yielding():\n        print(chunk)\nexcept NotAsyncCallableError as e:\n    print(f\"Wrong coroutine type: {e}\")\n</code></pre>"},{"location":"api-reference/exceptions/#solution","title":"Solution","text":"<p>Use the appropriate method:</p> <pre><code># For regular coroutines\nresult = await node.run()\n\n# For async generators\nasync for chunk in node.run_yielding():\n    print(chunk.output)\n</code></pre> <p>Or use <code>TreeExecutor</code> which handles both:</p> <pre><code>executor = TreeExecutor(roots=[node])\n\n# Works with both regular and yielding nodes\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        print(item.output)\n    elif isinstance(item, Node):\n        print(f\"{item.uuid} completed\")\n</code></pre>"},{"location":"api-reference/exceptions/#forwardingoverrideerror","title":"ForwardingOverrideError","text":""},{"location":"api-reference/exceptions/#description_2","title":"Description","text":"<p>Raised when attempting to forward data to a parameter that already has a value in the node's kwargs.</p> <p>This prevents accidental overwriting of explicitly set parameters.</p>"},{"location":"api-reference/exceptions/#signature_2","title":"Signature","text":"<pre><code>class ForwardingOverrideError(Exception):\n    \"\"\"Raised when forwarding would override an existing kwarg.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#when-raised_2","title":"When Raised","text":"<ul> <li>Using <code>forward_as=\"param\"</code> when <code>param</code> is already in the node's kwargs</li> </ul>"},{"location":"api-reference/exceptions/#example_2","title":"Example","text":"<pre><code>from grafo import Node\nfrom grafo.errors import ForwardingOverrideError\n\nasync def producer():\n    return \"data\"\n\nasync def consumer(value: str):\n    return f\"processed_{value}\"\n\nparent = Node(coroutine=producer, uuid=\"parent\")\n\n# Child already has 'value' set\nchild = Node(\n    coroutine=consumer,\n    uuid=\"child\",\n    kwargs=dict(value=\"preset_value\")  # Pre-set value\n)\n\ntry:\n    # Try to forward to the same parameter\n    await parent.connect(child, forward_as=\"value\")\nexcept ForwardingOverrideError as e:\n    print(f\"Forwarding conflict: {e}\")\n</code></pre>"},{"location":"api-reference/exceptions/#solutions","title":"Solutions","text":"<p>Option 1: Remove the pre-set value</p> <pre><code>child = Node(coroutine=consumer, uuid=\"child\")\nawait parent.connect(child, forward_as=\"value\")\n</code></pre> <p>Option 2: Use a different parameter name</p> <pre><code>async def consumer(value: str, other_value: str):\n    return f\"{value} and {other_value}\"\n\nchild = Node(\n    coroutine=consumer,\n    uuid=\"child\",\n    kwargs=dict(value=\"preset_value\")\n)\n\nawait parent.connect(child, forward_as=\"other_value\")\n</code></pre> <p>Option 3: Use manual forwarding with lambda</p> <pre><code>child = Node(\n    coroutine=consumer,\n    uuid=\"child\",\n    kwargs=dict(\n        value=lambda: parent.output  # Manual forwarding\n    )\n)\n\nawait parent.connect(child)  # No forward_as\n</code></pre>"},{"location":"api-reference/exceptions/#mismatchchunktype","title":"MismatchChunkType","text":""},{"location":"api-reference/exceptions/#description_3","title":"Description","text":"<p>Raised when a node's output doesn't match its declared generic type parameter.</p> <p>Enables runtime type validation for type-safe trees.</p>"},{"location":"api-reference/exceptions/#signature_3","title":"Signature","text":"<pre><code>class MismatchChunkType(Exception):\n    \"\"\"Raised when output type doesn't match the declared type parameter.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#when-raised_3","title":"When Raised","text":"<ul> <li>Node with type parameter <code>Node[T]</code> returns a value that's not type <code>T</code></li> <li>Yielding node with type parameter <code>Node[T]</code> yields a value that's not type <code>T</code></li> </ul>"},{"location":"api-reference/exceptions/#example_3","title":"Example","text":"<pre><code>from grafo import Node, TreeExecutor\nfrom grafo.errors import MismatchChunkType\n\nasync def return_wrong_type():\n    return 42  # Returns int\n\n# Declare as returning str\nnode = Node[str](coroutine=return_wrong_type, uuid=\"typed\")\n\nexecutor = TreeExecutor(roots=[node])\n\ntry:\n    await executor.run()\nexcept MismatchChunkType as e:\n    print(f\"Type mismatch: {e}\")\n    # Error message includes:\n    # - Node UUID\n    # - Expected type (str)\n    # - Actual type (int)\n</code></pre>"},{"location":"api-reference/exceptions/#with-yielding","title":"With Yielding","text":"<pre><code>async def yield_mixed_types():\n    yield \"string\"  # OK\n    yield 42        # Wrong type!\n    yield \"another\"\n\nnode = Node[str](coroutine=yield_mixed_types, uuid=\"yielder\")\n\ntry:\n    async for chunk in node.run_yielding():\n        print(chunk.output)\nexcept MismatchChunkType as e:\n    print(f\"Type mismatch on yield: {e}\")\n</code></pre>"},{"location":"api-reference/exceptions/#solutions_1","title":"Solutions","text":"<p>Option 1: Fix the return type</p> <pre><code>async def return_correct_type():\n    return \"string\"  # Returns str\n\nnode = Node[str](coroutine=return_correct_type, uuid=\"typed\")\n</code></pre> <p>Option 2: Change the type parameter</p> <pre><code>async def return_number():\n    return 42\n\nnode = Node[int](coroutine=return_number, uuid=\"typed\")\n</code></pre> <p>Option 3: Remove type validation</p> <pre><code>async def return_anything():\n    return 42\n\n# No type parameter = no validation\nnode = Node(coroutine=return_anything, uuid=\"untyped\")\n</code></pre> <p>Option 4: Use Union types</p> <pre><code>from typing import Union\n\nasync def return_str_or_int():\n    return 42  # or \"string\"\n\nnode = Node[Union[str, int]](coroutine=return_str_or_int, uuid=\"union\")\n</code></pre>"},{"location":"api-reference/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>Exception (built-in)\n\u251c\u2500\u2500 SafeExecutionError\n\u251c\u2500\u2500 NotAsyncCallableError\n\u251c\u2500\u2500 ForwardingOverrideError\n\u2514\u2500\u2500 MismatchChunkType\n</code></pre> <p>All Grafo exceptions inherit directly from Python's base <code>Exception</code> class.</p>"},{"location":"api-reference/exceptions/#catching-grafo-exceptions","title":"Catching Grafo Exceptions","text":""},{"location":"api-reference/exceptions/#catch-specific-exceptions","title":"Catch Specific Exceptions","text":"<pre><code>from grafo.errors import (\n    SafeExecutionError,\n    ForwardingOverrideError,\n    MismatchChunkType,\n    NotAsyncCallableError\n)\n\ntry:\n    await executor.run()\nexcept SafeExecutionError as e:\n    logger.error(f\"Execution conflict: {e}\")\nexcept ForwardingOverrideError as e:\n    logger.error(f\"Forwarding error: {e}\")\nexcept MismatchChunkType as e:\n    logger.error(f\"Type error: {e}\")\nexcept NotAsyncCallableError as e:\n    logger.error(f\"Wrong coroutine type: {e}\")\n</code></pre>"},{"location":"api-reference/exceptions/#catch-all-grafo-exceptions","title":"Catch All Grafo Exceptions","text":"<p>Since there's no common base class, catch them individually:</p> <pre><code>from grafo.errors import (\n    SafeExecutionError,\n    ForwardingOverrideError,\n    MismatchChunkType,\n    NotAsyncCallableError\n)\n\nGRAFO_EXCEPTIONS = (\n    SafeExecutionError,\n    ForwardingOverrideError,\n    MismatchChunkType,\n    NotAsyncCallableError\n)\n\ntry:\n    await executor.run()\nexcept GRAFO_EXCEPTIONS as e:\n    logger.error(f\"Grafo error: {type(e).__name__}: {e}\")\n</code></pre>"},{"location":"api-reference/exceptions/#best-practices","title":"Best Practices","text":"<ol> <li>Catch specific exceptions: Handle each error type appropriately</li> <li>Log with context: Include node UUIDs and relevant details</li> <li>Fail fast for logic errors: <code>ForwardingOverrideError</code> and <code>NotAsyncCallableError</code> indicate programming errors</li> <li>Handle runtime errors gracefully: <code>SafeExecutionError</code> can occur in concurrent scenarios</li> <li>Validate types early: Use type parameters to catch <code>MismatchChunkType</code> during development</li> </ol>"},{"location":"api-reference/exceptions/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nimport logging\nfrom grafo import Node, TreeExecutor, Chunk\nfrom grafo.errors import (\n    SafeExecutionError,\n    ForwardingOverrideError,\n    MismatchChunkType,\n    NotAsyncCallableError\n)\n\nlogger = logging.getLogger(__name__)\n\nasync def safe_execution_example():\n    \"\"\"Handle all Grafo exceptions gracefully.\"\"\"\n\n    try:\n        # Build tree\n        async def task_a() -&gt; str:\n            return \"result\"\n\n        async def task_b(data: str) -&gt; str:\n            return f\"processed_{data}\"\n\n        node_a = Node[str](coroutine=task_a, uuid=\"a\")\n        node_b = Node[str](coroutine=task_b, uuid=\"b\")\n\n        # Connect with forwarding\n        await node_a.connect(node_b, forward_as=\"data\")\n\n        # Execute\n        executor = TreeExecutor(uuid=\"Safe Tree\", roots=[node_a])\n        await executor.run()\n\n        logger.info(\"Execution successful\")\n\n    except ForwardingOverrideError as e:\n        logger.error(f\"Forwarding conflict: {e}\")\n        # Fix: Check node kwargs before forwarding\n\n    except MismatchChunkType as e:\n        logger.error(f\"Type validation failed: {e}\")\n        # Fix: Ensure coroutines return correct types\n\n    except NotAsyncCallableError as e:\n        logger.error(f\"Wrong coroutine type: {e}\")\n        # Fix: Use correct method (run vs run_yielding)\n\n    except SafeExecutionError as e:\n        logger.error(f\"Execution conflict: {e}\")\n        # Fix: Don't modify nodes during execution\n\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n        raise\n\nasyncio.run(safe_execution_example())\n</code></pre>"},{"location":"api-reference/exceptions/#see-also","title":"See Also","text":"<ul> <li>Error Handling Guide - Comprehensive error handling patterns</li> <li>Node API - Node methods that raise exceptions</li> <li>TreeExecutor API - Executor error tracking</li> </ul>"},{"location":"api-reference/executor/","title":"TreeExecutor API Reference","text":"<p>Complete API documentation for the <code>TreeExecutor</code> class.</p>"},{"location":"api-reference/executor/#class-definition","title":"Class Definition","text":"<pre><code>class TreeExecutor(Generic[N]):\n    \"\"\"\n    Orchestrates execution of async node trees.\n\n    Manages worker pool, dependency resolution, and result streaming.\n\n    Type Parameters:\n        N: The type of nodes in the tree\n    \"\"\"\n</code></pre>"},{"location":"api-reference/executor/#constructor","title":"Constructor","text":"<pre><code>TreeExecutor(\n    *,\n    uuid: str,\n    description: Optional[str] = None,\n    roots: Optional[list[Node]] = None\n)\n</code></pre>"},{"location":"api-reference/executor/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>uuid</code> <code>str</code> Required Unique identifier for the executor <code>description</code> <code>Optional[str]</code> <code>None</code> Optional description of the tree <code>roots</code> <code>Optional[list[Node]]</code> <code>None</code> List of root nodes to start execution from"},{"location":"api-reference/executor/#example","title":"Example","text":"<pre><code>from grafo import TreeExecutor, Node\n\nroot_a = Node(coroutine=task_a, uuid=\"root_a\")\nroot_b = Node(coroutine=task_b, uuid=\"root_b\")\n\nexecutor = TreeExecutor(\n    uuid=\"My Tree\",\n    description=\"Multi-root data processing tree\",\n    roots=[root_a, root_b]\n)\n</code></pre>"},{"location":"api-reference/executor/#properties","title":"Properties","text":""},{"location":"api-reference/executor/#name","title":"name","text":"<pre><code>@property\ndef name(self) -&gt; str:\n    \"\"\"The UUID of the executor.\"\"\"\n</code></pre> <p>Example: <pre><code>print(f\"Executing tree: {executor.name}\")\n</code></pre></p>"},{"location":"api-reference/executor/#description","title":"description","text":"<pre><code>@property\ndef description(self) -&gt; Optional[str]:\n    \"\"\"Optional description of the executor.\"\"\"\n</code></pre>"},{"location":"api-reference/executor/#roots","title":"roots","text":"<pre><code>@property\ndef roots(self) -&gt; list[Node]:\n    \"\"\"List of root nodes.\"\"\"\n</code></pre> <p>Example: <pre><code>print(f\"Tree has {len(executor.roots)} root nodes\")\nfor root in executor.roots:\n    print(f\"  - {root.uuid}\")\n</code></pre></p>"},{"location":"api-reference/executor/#errors","title":"errors","text":"<pre><code>@property\ndef errors(self) -&gt; list[Exception]:\n    \"\"\"List of errors encountered during execution.\"\"\"\n</code></pre> <p>Example: <pre><code>await executor.run()\n\nif executor.errors:\n    print(\"Errors occurred:\")\n    for error in executor.errors:\n        print(f\"  - {error}\")\n</code></pre></p>"},{"location":"api-reference/executor/#methods","title":"Methods","text":""},{"location":"api-reference/executor/#run","title":"run","text":"<pre><code>async def run(self) -&gt; tuple[list[Node], list[Chunk]]:\n    \"\"\"\n    Execute the entire tree and return all results.\n\n    Waits for all nodes to complete before returning.\n\n    Returns:\n        Tuple of (completed_nodes, all_chunks)\n        - completed_nodes: List of all executed nodes\n        - all_chunks: List of all chunks from yielding nodes\n\n    Raises:\n        Exceptions from node execution propagate normally\n    \"\"\"\n</code></pre> <p>Example: <pre><code>executor = TreeExecutor(uuid=\"Tree\", roots=[root])\n\n# Execute and get results\nnodes, chunks = await executor.run()\n\nprint(f\"Executed {len(nodes)} nodes\")\nprint(f\"Collected {len(chunks)} chunks\")\n\n# Access individual node outputs\nfor node in nodes:\n    print(f\"{node.uuid}: {node.output}\")\n</code></pre></p>"},{"location":"api-reference/executor/#yielding","title":"yielding","text":"<pre><code>async def yielding(\n    self,\n    latency: float = 0.2\n) -&gt; AsyncGenerator[Union[Node, Chunk], None]:\n    \"\"\"\n    Execute the tree and stream results as they complete.\n\n    Args:\n        latency: Check interval in seconds (default: 0.2)\n\n    Yields:\n        Node objects when nodes complete, or Chunk objects for intermediate results\n\n    Raises:\n        Exceptions from node execution propagate normally\n    \"\"\"\n</code></pre> <p>Example: <pre><code>executor = TreeExecutor(uuid=\"Streaming Tree\", roots=[root])\n\nasync for item in executor.yielding(latency=0.1):\n    if isinstance(item, Chunk):\n        print(f\"[{item.uuid}] Progress: {item.output}\")\n    elif isinstance(item, Node):\n        print(f\"Node {item.uuid} completed: {item.output}\")\n</code></pre></p> <p>Latency Parameter:</p> <ul> <li>Lower latency = more responsive but higher CPU usage</li> <li>Higher latency = less CPU usage but slower response</li> <li>Default (0.2s) is a good balance for most use cases</li> </ul>"},{"location":"api-reference/executor/#get_leaves","title":"get_leaves","text":"<pre><code>def get_leaves(self) -&gt; list[Node]:\n    \"\"\"\n    Get all leaf nodes (nodes with no children).\n\n    Returns:\n        List of leaf nodes in the tree\n\n    Raises:\n        ValueError: If roots list is empty\n    \"\"\"\n</code></pre> <p>Example: <pre><code>executor = TreeExecutor(uuid=\"Tree\", roots=[root])\n\n# Get leaf nodes\nleaves = executor.get_leaves()\n\nprint(f\"Found {len(leaves)} leaf nodes:\")\nfor leaf in leaves:\n    print(f\"  - {leaf.uuid}\")\n</code></pre></p>"},{"location":"api-reference/executor/#stop_tree","title":"stop_tree","text":"<pre><code>async def stop_tree(self) -&gt; None:\n    \"\"\"\n    Gracefully stop tree execution.\n\n    Signals workers to stop processing new nodes.\n    \"\"\"\n</code></pre> <p>Example: <pre><code>import asyncio\n\nasync def run_with_timeout():\n    executor = TreeExecutor(roots=[root])\n\n    # Run for maximum 10 seconds\n    try:\n        await asyncio.wait_for(executor.run(), timeout=10)\n    except asyncio.TimeoutError:\n        print(\"Execution timed out, stopping...\")\n        await executor.stop_tree()\n</code></pre></p>"},{"location":"api-reference/executor/#execution-behavior","title":"Execution Behavior","text":""},{"location":"api-reference/executor/#worker-management","title":"Worker Management","text":"<p>The executor automatically manages a pool of async workers:</p> <ul> <li>Workers scale dynamically based on queue size</li> <li>No manual configuration needed</li> <li>Efficient resource utilization</li> </ul>"},{"location":"api-reference/executor/#dependency-resolution","title":"Dependency Resolution","text":"<p>Nodes execute according to these rules:</p> <ol> <li>Root nodes start immediately</li> <li>A node waits for ALL parent nodes to complete</li> <li>Independent branches execute in parallel</li> <li>Execution continues until all nodes complete</li> </ol>"},{"location":"api-reference/executor/#example-execution-flow","title":"Example Execution Flow","text":"<pre><code># Tree structure:\n#     A\n#    / \\\n#   B   C\n#    \\ /\n#     D\n\n# Execution order:\n# 1. A starts (root)\n# 2. A completes\n# 3. B and C start in parallel\n# 4. B and C complete\n# 5. D starts (waits for both B and C)\n# 6. D completes\n</code></pre>"},{"location":"api-reference/executor/#return-values","title":"Return Values","text":""},{"location":"api-reference/executor/#run-return-value","title":"run() Return Value","text":"<pre><code>nodes, chunks = await executor.run()\n\n# nodes: List[Node]\n# - All executed nodes from the tree\n# - Access node.output for results\n# - Access node.metadata for execution info\n\n# chunks: List[Chunk]\n# - All chunks from yielding nodes\n# - Empty list if no nodes use yielding\n</code></pre>"},{"location":"api-reference/executor/#yielding-yield-values","title":"yielding() Yield Values","text":"<pre><code>async for item in executor.yielding():\n    if isinstance(item, Chunk):\n        # Intermediate result from yielding node\n        source_uuid = item.uuid\n        value = item.output\n\n    elif isinstance(item, Node):\n        # Node completed\n        result = item.output\n        runtime = item.metadata.runtime\n</code></pre>"},{"location":"api-reference/executor/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/executor/#exceptions","title":"Exceptions","text":"<p>Exceptions from node execution propagate to the executor:</p> <pre><code>try:\n    await executor.run()\nexcept ValueError as e:\n    print(f\"Node raised ValueError: {e}\")\nexcept asyncio.TimeoutError:\n    print(\"A node timed out\")\n</code></pre>"},{"location":"api-reference/executor/#error-tracking","title":"Error Tracking","text":"<p>The executor collects errors:</p> <pre><code>await executor.run()\n\nif executor.errors:\n    print(f\"Encountered {len(executor.errors)} errors\")\n    for i, error in enumerate(executor.errors, 1):\n        print(f\"{i}. {type(error).__name__}: {error}\")\n</code></pre>"},{"location":"api-reference/executor/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom grafo import Node, TreeExecutor, Chunk\n\n# Define tasks\nasync def fetch_users():\n    await asyncio.sleep(1)\n    return [\"alice\", \"bob\", \"charlie\"]\n\nasync def process_user(username: str):\n    for step in [\"validate\", \"enrich\", \"format\"]:\n        await asyncio.sleep(0.5)\n        yield f\"{username}:{step}\"\n    yield f\"DONE:{username}\"\n\nasync def aggregate_users(users: list):\n    return {\"total\": len(users), \"users\": users}\n\nasync def main():\n    # Create nodes\n    fetcher = Node[list](\n        coroutine=fetch_users,\n        uuid=\"fetcher\"\n    )\n\n    processors = [\n        Node[str](\n            coroutine=process_user,\n            uuid=f\"processor_{i}\",\n            kwargs=dict(username=lambda idx=i: fetcher.output[idx])\n        )\n        for i in range(3)\n    ]\n\n    aggregator = Node[dict](\n        coroutine=aggregate_users,\n        uuid=\"aggregator\",\n        kwargs=dict(users=lambda: [p.output for p in processors])\n    )\n\n    # Build tree\n    for processor in processors:\n        await fetcher.connect(processor)\n        await processor.connect(aggregator)\n\n    # Create executor\n    executor = TreeExecutor(\n        uuid=\"User Processing Pipeline\",\n        description=\"Fetch, process, and aggregate user data\",\n        roots=[fetcher]\n    )\n\n    print(f\"Executing: {executor.name}\")\n    if executor.description:\n        print(f\"Description: {executor.description}\")\n\n    # Stream results\n    async for item in executor.yielding(latency=0.1):\n        if isinstance(item, Chunk):\n            print(f\"  Progress: {item.output}\")\n        elif isinstance(item, Node):\n            print(f\"  \u2713 {item.uuid} completed\")\n\n    # Show final results\n    print(f\"\\nFinal aggregation: {aggregator.output}\")\n\n    # Show leaf nodes\n    leaves = executor.get_leaves()\n    print(f\"\\nLeaf nodes: {[leaf.uuid for leaf in leaves]}\")\n\n    # Check for errors\n    if executor.errors:\n        print(f\"\\nErrors: {executor.errors}\")\n\nasyncio.run(main())\n</code></pre> <p>Output: <pre><code>Executing: User Processing Pipeline\nDescription: Fetch, process, and aggregate user data\n  \u2713 fetcher completed\n  Progress: alice:validate\n  Progress: bob:validate\n  Progress: charlie:validate\n  Progress: alice:enrich\n  Progress: bob:enrich\n  Progress: charlie:enrich\n  Progress: alice:format\n  Progress: bob:format\n  Progress: charlie:format\n  Progress: DONE:alice\n  Progress: DONE:bob\n  Progress: DONE:charlie\n  \u2713 processor_0 completed\n  \u2713 processor_1 completed\n  \u2713 processor_2 completed\n  \u2713 aggregator completed\n\nFinal aggregation: {'total': 3, 'users': ['DONE:alice', 'DONE:bob', 'DONE:charlie']}\n\nLeaf nodes: ['aggregator']\n</code></pre></p>"},{"location":"api-reference/executor/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api-reference/executor/#latency-tuning","title":"Latency Tuning","text":"<pre><code># High responsiveness (more CPU)\nasync for item in executor.yielding(latency=0.05):\n    ...\n\n# Balanced (default)\nasync for item in executor.yielding(latency=0.2):\n    ...\n\n# Lower CPU usage\nasync for item in executor.yielding(latency=0.5):\n    ...\n</code></pre>"},{"location":"api-reference/executor/#memory-usage","title":"Memory Usage","text":"<ul> <li><code>run()</code> collects all results in memory</li> <li><code>yielding()</code> streams results, lower memory footprint</li> <li>For large trees, prefer <code>yielding()</code> and process results incrementally</li> </ul>"},{"location":"api-reference/executor/#see-also","title":"See Also","text":"<ul> <li>Node - Node API documentation</li> <li>Chunk - Chunk data structure</li> <li>Exceptions - Error types</li> </ul>"},{"location":"api-reference/node/","title":"Node API Reference","text":"<p>Complete API documentation for the <code>Node</code> class.</p>"},{"location":"api-reference/node/#class-definition","title":"Class Definition","text":"<pre><code>class Node(Generic[N]):\n    \"\"\"\n    A node in an async execution tree.\n\n    Type Parameters:\n        N: The expected return type of the coroutine\n    \"\"\"\n</code></pre>"},{"location":"api-reference/node/#constructor","title":"Constructor","text":"<pre><code>Node(\n    coroutine: AwaitableCallback,\n    *,\n    uuid: str,\n    kwargs: Optional[dict] = None,\n    timeout: int = 60,\n    on_connect: Optional[Callable] = None,\n    on_disconnect: Optional[Callable] = None,\n    on_before_run: Optional[Callable] = None,\n    on_after_run: Optional[Callable] = None\n)\n</code></pre>"},{"location":"api-reference/node/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>coroutine</code> <code>AwaitableCallback</code> Required The async function to execute <code>uuid</code> <code>str</code> Required Unique identifier for the node <code>kwargs</code> <code>Optional[dict]</code> <code>None</code> Arguments to pass to the coroutine. Values can be static or lambda functions for dynamic evaluation <code>timeout</code> <code>int</code> <code>60</code> Maximum execution time in seconds <code>on_connect</code> <code>Optional[Callable]</code> <code>None</code> Async callback when connecting to a child <code>on_disconnect</code> <code>Optional[Callable]</code> <code>None</code> Async callback when disconnecting from a child <code>on_before_run</code> <code>Optional[Callable]</code> <code>None</code> Async callback before execution <code>on_after_run</code> <code>Optional[Callable]</code> <code>None</code> Async callback after execution"},{"location":"api-reference/node/#example","title":"Example","text":"<pre><code>async def my_task(value: int):\n    return value * 2\n\nnode = Node(\n    coroutine=my_task,\n    uuid=\"doubler\",\n    kwargs=dict(value=5),\n    timeout=30,\n    on_before_run=lambda n: print(f\"Starting {n.uuid}\")\n)\n</code></pre>"},{"location":"api-reference/node/#properties","title":"Properties","text":""},{"location":"api-reference/node/#output","title":"output","text":"<pre><code>@property\ndef output(self) -&gt; Optional[N]:\n    \"\"\"The return value of the coroutine after execution.\"\"\"\n</code></pre> <p>Returns <code>None</code> before execution completes.</p> <p>Example: <pre><code>await node.run()\nresult = node.output  # Access the result\n</code></pre></p>"},{"location":"api-reference/node/#aggregated_output","title":"aggregated_output","text":"<pre><code>@property\ndef aggregated_output(self) -&gt; list:\n    \"\"\"List of outputs from all child nodes.\"\"\"\n</code></pre> <p>Example: <pre><code>parent = Node(coroutine=producer, uuid=\"parent\")\nchild_a = Node(coroutine=task_a, uuid=\"a\")\nchild_b = Node(coroutine=task_b, uuid=\"b\")\n\nawait parent.connect(child_a)\nawait parent.connect(child_b)\n\nawait executor.run()\n\n# Get all child outputs\nchildren_outputs = parent.aggregated_output  # [output_a, output_b]\n</code></pre></p>"},{"location":"api-reference/node/#metadata","title":"metadata","text":"<pre><code>@property\ndef metadata(self) -&gt; Metadata:\n    \"\"\"Execution metadata (runtime, tree level).\"\"\"\n</code></pre> <p>Returns a <code>Metadata</code> dataclass with: - <code>runtime</code>: Execution time in seconds (float) - <code>level</code>: Depth in tree, starting from 0 for roots (int)</p> <p>Example: <pre><code>await node.run()\nprint(f\"Executed in {node.metadata.runtime}s\")\nprint(f\"Tree level: {node.metadata.level}\")\n</code></pre></p>"},{"location":"api-reference/node/#parents","title":"parents","text":"<pre><code>@property\ndef parents(self) -&gt; set[Node]:\n    \"\"\"Set of parent nodes.\"\"\"\n</code></pre>"},{"location":"api-reference/node/#children","title":"children","text":"<pre><code>@property\ndef children(self) -&gt; set[Node]:\n    \"\"\"Set of child nodes.\"\"\"\n</code></pre>"},{"location":"api-reference/node/#uuid","title":"uuid","text":"<pre><code>@property\ndef uuid(self) -&gt; str:\n    \"\"\"Unique identifier for the node.\"\"\"\n</code></pre>"},{"location":"api-reference/node/#methods","title":"Methods","text":""},{"location":"api-reference/node/#connect","title":"connect","text":"<pre><code>async def connect(\n    self,\n    target: Node,\n    *,\n    forward_as: Optional[str] = None,\n    on_before_forward: Optional[OnForwardCallable] = None\n) -&gt; None:\n    \"\"\"\n    Connect this node to a child node.\n\n    Args:\n        target: The child node to connect to\n        forward_as: Parameter name to forward this node's output to\n        on_before_forward: Async callback to transform forwarded value\n\n    Raises:\n        ForwardingOverrideError: If forward_as conflicts with existing kwarg\n        SafeExecutionError: If node is currently running\n    \"\"\"\n</code></pre> <p>Example: <pre><code>await parent.connect(child)  # Basic connection\n\nawait parent.connect(child, forward_as=\"data\")  # With forwarding\n\nasync def transform(parent, child, value):\n    return value.upper()\n\nawait parent.connect(\n    child,\n    forward_as=\"data\",\n    on_before_forward=transform\n)\n</code></pre></p>"},{"location":"api-reference/node/#disconnect","title":"disconnect","text":"<pre><code>async def disconnect(self, target: Node) -&gt; None:\n    \"\"\"\n    Disconnect this node from a child node.\n\n    Args:\n        target: The child node to disconnect from\n\n    Raises:\n        SafeExecutionError: If node is currently running\n    \"\"\"\n</code></pre> <p>Example: <pre><code>await parent.disconnect(child)\n</code></pre></p>"},{"location":"api-reference/node/#redirect","title":"redirect","text":"<pre><code>async def redirect(self, targets: list[Node]) -&gt; None:\n    \"\"\"\n    Disconnect all current children and connect to new targets.\n\n    Args:\n        targets: List of new child nodes\n\n    Raises:\n        SafeExecutionError: If node is currently running\n    \"\"\"\n</code></pre> <p>Example: <pre><code># Current children: [old_a, old_b]\nawait parent.redirect([new_a, new_b, new_c])\n# Current children: [new_a, new_b, new_c]\n</code></pre></p>"},{"location":"api-reference/node/#run","title":"run","text":"<pre><code>async def run(self) -&gt; N:\n    \"\"\"\n    Execute the node's coroutine.\n\n    Returns:\n        The coroutine's return value\n\n    Raises:\n        asyncio.TimeoutError: If execution exceeds timeout\n        NotAsyncCallableError: If coroutine is an async generator\n        MismatchChunkType: If return type doesn't match generic parameter\n    \"\"\"\n</code></pre> <p>Example: <pre><code>node = Node(coroutine=my_task, uuid=\"task\")\nresult = await node.run()\n</code></pre></p>"},{"location":"api-reference/node/#run_yielding","title":"run_yielding","text":"<pre><code>async def run_yielding(self) -&gt; AsyncGenerator[Chunk[N], None]:\n    \"\"\"\n    Execute the node's async generator coroutine, yielding chunks.\n\n    Yields:\n        Chunk objects wrapping intermediate results\n\n    Raises:\n        asyncio.TimeoutError: If execution exceeds timeout\n        NotAsyncCallableError: If coroutine is not an async generator\n        MismatchChunkType: If yielded type doesn't match generic parameter\n    \"\"\"\n</code></pre> <p>Example: <pre><code>async def yielding_task():\n    for i in range(5):\n        yield i\n\nnode = Node(coroutine=yielding_task, uuid=\"yielder\")\n\nasync for chunk in node.run_yielding():\n    print(f\"Got: {chunk.output}\")\n</code></pre></p>"},{"location":"api-reference/node/#type-parameters","title":"Type Parameters","text":""},{"location":"api-reference/node/#generic-type-validation","title":"Generic Type Validation","text":"<p>Specify expected return type:</p> <pre><code># Node that returns string\nstring_node = Node[str](coroutine=return_string, uuid=\"str\")\n\n# Node that returns int\nint_node = Node[int](coroutine=return_int, uuid=\"int\")\n\n# Node that returns custom type\nuser_node = Node[User](coroutine=get_user, uuid=\"user\")\n</code></pre> <p>Without type parameter, no validation occurs:</p> <pre><code># No type validation\nany_node = Node(coroutine=return_anything, uuid=\"any\")\n</code></pre>"},{"location":"api-reference/node/#event-callbacks","title":"Event Callbacks","text":""},{"location":"api-reference/node/#on_connect","title":"on_connect","text":"<pre><code>async def on_connect_callback(parent: Node, child: Node) -&gt; None:\n    \"\"\"Called when parent connects to child.\"\"\"\n</code></pre>"},{"location":"api-reference/node/#on_disconnect","title":"on_disconnect","text":"<pre><code>async def on_disconnect_callback(parent: Node, child: Node) -&gt; None:\n    \"\"\"Called when parent disconnects from child.\"\"\"\n</code></pre>"},{"location":"api-reference/node/#on_before_run","title":"on_before_run","text":"<pre><code>async def on_before_run_callback(node: Node) -&gt; None:\n    \"\"\"Called before node execution.\"\"\"\n</code></pre>"},{"location":"api-reference/node/#on_after_run","title":"on_after_run","text":"<pre><code>async def on_after_run_callback(node: Node) -&gt; None:\n    \"\"\"Called after node execution. Node.output and Node.metadata are available.\"\"\"\n</code></pre>"},{"location":"api-reference/node/#on_before_forward","title":"on_before_forward","text":"<pre><code>async def on_before_forward_callback(\n    parent: Node,\n    child: Node,\n    value: Any\n) -&gt; Any:\n    \"\"\"\n    Called before forwarding value to child.\n    Can transform the value.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/node/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom grafo import Node, TreeExecutor\n\nasync def extract_data(source: str):\n    \"\"\"Extract data from source.\"\"\"\n    await asyncio.sleep(1)\n    return f\"data_from_{source}\"\n\nasync def transform_data(data: str):\n    \"\"\"Transform extracted data.\"\"\"\n    await asyncio.sleep(0.5)\n    return data.upper()\n\nasync def load_data(data: str):\n    \"\"\"Load transformed data.\"\"\"\n    await asyncio.sleep(0.5)\n    print(f\"Loaded: {data}\")\n    return \"success\"\n\nasync def log_before(node: Node):\n    print(f\"Starting {node.uuid}\")\n\nasync def log_after(node: Node):\n    print(f\"Completed {node.uuid} in {node.metadata.runtime}s\")\n\nasync def main():\n    # Create nodes\n    extractor = Node[str](\n        coroutine=extract_data,\n        uuid=\"extractor\",\n        kwargs=dict(source=\"database\"),\n        timeout=30,\n        on_before_run=log_before,\n        on_after_run=log_after\n    )\n\n    transformer = Node[str](\n        coroutine=transform_data,\n        uuid=\"transformer\",\n        on_before_run=log_before,\n        on_after_run=log_after\n    )\n\n    loader = Node[str](\n        coroutine=load_data,\n        uuid=\"loader\",\n        on_before_run=log_before,\n        on_after_run=log_after\n    )\n\n    # Build pipeline\n    await extractor.connect(transformer, forward_as=\"data\")\n    await transformer.connect(loader, forward_as=\"data\")\n\n    # Execute\n    executor = TreeExecutor(uuid=\"ETL Pipeline\", roots=[extractor])\n    await executor.run()\n\n    # Access results\n    print(f\"Extractor output: {extractor.output}\")\n    print(f\"Transformer output: {transformer.output}\")\n    print(f\"Loader output: {loader.output}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"api-reference/node/#see-also","title":"See Also","text":"<ul> <li>TreeExecutor - Execute node trees</li> <li>Chunk - Wrapper for yielded values</li> <li>Exceptions - Error types</li> </ul>"},{"location":"getting-started/core-concepts/","title":"Core Concepts","text":"<p>Understanding these fundamental concepts will help you use Grafo effectively.</p>"},{"location":"getting-started/core-concepts/#nodes","title":"Nodes","text":"<p>A Node wraps an async coroutine function as a unit of work in your tree. Each node:</p> <ul> <li>Executes an async function</li> <li>Has a unique identifier (UUID)</li> <li>Connects to parent and child nodes</li> <li>Waits for all parents before executing</li> <li>Stores output and execution metadata</li> </ul> <p>Key principle: A node only runs after ALL its parents complete.</p>"},{"location":"getting-started/core-concepts/#trees","title":"Trees","text":"<p>A tree is a directed acyclic graph (DAG) of connected nodes where:</p> <ul> <li>Root nodes have no parents (entry points)</li> <li>Leaf nodes have no children (endpoints)</li> <li>Connections define execution dependencies</li> </ul> <p>Trees are: - Directed: Data flows parent \u2192 child - Acyclic: No circular dependencies allowed - Flexible: Can have multiple roots, any shape</p>"},{"location":"getting-started/core-concepts/#execution","title":"Execution","text":"<p>The TreeExecutor orchestrates execution:</p> <ol> <li>Queues all root nodes</li> <li>Executes nodes whose parents are complete</li> <li>Manages worker pool dynamically</li> <li>Continues until all nodes finish</li> </ol> <p>Workers scale automatically based on the queue - no manual configuration needed.</p>"},{"location":"getting-started/core-concepts/#state-passing","title":"State Passing","text":"<p>Pass data between nodes using:</p> <ul> <li>Automatic forwarding: Specify parameter mapping with <code>forward_as</code></li> <li>Manual forwarding: Use lambda functions for dynamic evaluation</li> </ul> <p>Choose automatic for simple pass-through, manual for transformations.</p>"},{"location":"getting-started/core-concepts/#yielding","title":"Yielding","text":"<p>Async generator nodes can yield intermediate results wrapped in Chunk objects:</p> <ul> <li>Stream progress updates in real-time</li> <li>Monitor long-running operations</li> <li>Access results as they're produced</li> </ul> <p>Use <code>executor.yielding()</code> instead of <code>executor.run()</code> to receive results progressively.</p>"},{"location":"getting-started/core-concepts/#type-validation","title":"Type Validation","text":"<p>Add runtime type checking with Python generics:</p> <pre><code>node = Node[str](coroutine=returns_string, uuid=\"typed\")\n</code></pre> <p>Validates both regular returns and yielded values against the specified type.</p>"},{"location":"getting-started/core-concepts/#metadata","title":"Metadata","text":"<p>After execution, each node provides:</p> <ul> <li><code>node.output</code>: The coroutine's return value</li> <li><code>node.metadata.runtime</code>: Execution time in seconds</li> <li><code>node.metadata.level</code>: Depth in tree (0 for roots)</li> </ul>"},{"location":"getting-started/core-concepts/#event-callbacks","title":"Event Callbacks","text":"<p>Hook into node lifecycle for monitoring and logging:</p> <ul> <li><code>on_connect</code> / <code>on_disconnect</code>: Connection events</li> <li><code>on_before_run</code> / <code>on_after_run</code>: Execution events</li> <li><code>on_before_forward</code>: Data forwarding events</li> </ul> <p>Callbacks are tuples of <code>(async_function, kwargs_dict)</code>. The kwargs dict can contain lambdas for dynamic evaluation.</p>"},{"location":"getting-started/core-concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the concepts, learn how to use them:</p> <ul> <li>Basic Usage - Create and connect nodes</li> <li>Building Trees - Tree structures and patterns</li> <li>Forwarding Data - Pass state between nodes</li> <li>Yielding Results - Stream intermediate results</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>Grafo requires Python 3.6 or higher.</p>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The simplest way to install Grafo is via pip:</p> <pre><code>pip install grafo\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Verify that Grafo is installed correctly:</p> <pre><code>import grafo\nprint(grafo.__version__)  # Should print the version number\n</code></pre> <p>Or run a quick test:</p> <pre><code>import asyncio\nfrom grafo import Node, TreeExecutor\n\nasync def hello():\n    return \"Hello, Grafo!\"\n\nasync def main():\n    node = Node(coroutine=hello, uuid=\"hello\")\n    executor = TreeExecutor(uuid=\"Test\", roots=[node])\n    await executor.run()\n    print(node.output)  # Should print: Hello, Grafo!\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Grafo installed, continue to the Quick Start guide to build your first async tree.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will walk you through creating your first async tree with Grafo.</p>"},{"location":"getting-started/quick-start/#your-first-tree","title":"Your First Tree","text":"<p>Create a simple tree with two nodes using automatic forwarding:</p> <pre><code>import asyncio\nfrom grafo import Node, TreeExecutor\n\nasync def greet():\n    return \"Hello\"\n\nasync def add_name(greeting: str):\n    return f\"{greeting}, World!\"\n\nasync def main():\n    # Create nodes\n    node_a = Node(coroutine=greet, uuid=\"greet\")\n    node_b = Node(coroutine=add_name, uuid=\"add_name\")\n\n    # Connect with automatic forwarding\n    await node_a.connect(node_b, forward_as=\"greeting\")\n\n    # Execute tree\n    executor = TreeExecutor(uuid=\"Greeting Tree\", roots=[node_a])\n    await executor.run()\n\n    print(node_b.output)  # \"Hello, World!\"\n\nasyncio.run(main())\n</code></pre> <p>Key concepts: - <code>Node</code> wraps an async function with a unique UUID - <code>connect()</code> creates parent-child relationships - <code>forward_as=\"greeting\"</code> automatically passes node_a's output to node_b's <code>greeting</code> parameter - <code>TreeExecutor</code> orchestrates execution, ensuring parents run before children</p>"},{"location":"getting-started/quick-start/#parallel-execution","title":"Parallel Execution","text":"<p>Multiple branches execute in parallel:</p> <pre><code>async def root_task():\n    return \"data\"\n\nasync def process(data: str, label: str):\n    return f\"{label}: {data}\"\n\nroot = Node(coroutine=root_task, uuid=\"root\")\nbranch_a = Node(coroutine=process, uuid=\"a\", kwargs=dict(label=\"A\"))\nbranch_b = Node(coroutine=process, uuid=\"b\", kwargs=dict(label=\"B\"))\n\nawait root.connect(branch_a, forward_as=\"data\")\nawait root.connect(branch_b, forward_as=\"data\")\n\nexecutor = TreeExecutor(roots=[root])\nawait executor.run()\n# Both branches run simultaneously after root completes\n</code></pre>"},{"location":"getting-started/quick-start/#streaming-results","title":"Streaming Results","text":"<p>Stream intermediate results from async generators:</p> <pre><code>from grafo import Chunk\n\nasync def counting_task():\n    for i in range(3):\n        yield f\"Step {i}\"\n\nnode = Node(coroutine=counting_task, uuid=\"counter\")\nexecutor = TreeExecutor(roots=[node])\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        print(f\"Progress: {item.output}\")\n    elif isinstance(item, Node):\n        print(f\"Completed: {item.uuid}\")\n</code></pre>"},{"location":"getting-started/quick-start/#manual-forwarding","title":"Manual Forwarding","text":"<p>Use lambdas for dynamic evaluation or transformations:</p> <pre><code>async def producer():\n    return \"data\"\n\nasync def consumer(value: str):\n    return value.upper()\n\nnode_a = Node(coroutine=producer, uuid=\"producer\")\nnode_b = Node(\n    coroutine=consumer,\n    uuid=\"consumer\",\n    kwargs=dict(value=lambda: node_a.output.upper())  # Transform on access\n)\n\nawait node_a.connect(node_b)\n</code></pre>"},{"location":"getting-started/quick-start/#type-validation","title":"Type Validation","text":"<p>Validate return types at runtime:</p> <pre><code>async def return_string():\n    return \"text\"\n\n# Specify expected type - validates at runtime\nnode = Node[str](coroutine=return_string, uuid=\"typed\")\n# Raises MismatchChunkType if return type is wrong\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore:</p> <ul> <li>Core Concepts - Deep dive into nodes, trees, and execution</li> <li>Building Trees - Advanced tree structures</li> <li>Forwarding Data - Master state passing</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>Common operations with nodes and executors.</p>"},{"location":"user-guide/basic-usage/#creating-nodes","title":"Creating Nodes","text":""},{"location":"user-guide/basic-usage/#simple-node","title":"Simple Node","text":"<pre><code>from grafo import Node\n\nasync def my_task():\n    return \"result\"\n\nnode = Node(coroutine=my_task, uuid=\"task_1\")\n</code></pre>"},{"location":"user-guide/basic-usage/#node-with-parameters","title":"Node with Parameters","text":"<pre><code>async def add_numbers(a: int, b: int):\n    return a + b\n\nnode = Node(\n    coroutine=add_numbers,\n    uuid=\"adder\",\n    kwargs=dict(a=5, b=3),\n    timeout=30  # Optional timeout in seconds (default: 60)\n)\n</code></pre>"},{"location":"user-guide/basic-usage/#connecting-nodes","title":"Connecting Nodes","text":""},{"location":"user-guide/basic-usage/#basic-connection","title":"Basic Connection","text":"<pre><code>await parent.connect(child)\n</code></pre>"},{"location":"user-guide/basic-usage/#with-forwarding","title":"With Forwarding","text":"<pre><code>await parent.connect(child, forward_as=\"input_param\")\n</code></pre>"},{"location":"user-guide/basic-usage/#multiple-children-parallel","title":"Multiple Children (Parallel)","text":"<pre><code>await parent.connect(child_a)\nawait parent.connect(child_b)\nawait parent.connect(child_c)\n# All children run in parallel after parent completes\n</code></pre>"},{"location":"user-guide/basic-usage/#multiple-parents-fan-in","title":"Multiple Parents (Fan-in)","text":"<pre><code>await parent_a.connect(child, forward_as=\"param_a\")\nawait parent_b.connect(child, forward_as=\"param_b\")\n# Child waits for BOTH parents before running\n</code></pre>"},{"location":"user-guide/basic-usage/#executing-trees","title":"Executing Trees","text":""},{"location":"user-guide/basic-usage/#basic-execution","title":"Basic Execution","text":"<pre><code>from grafo import TreeExecutor\n\nexecutor = TreeExecutor(uuid=\"My Tree\", roots=[root_node])\nawait executor.run()\n\n# Access results\nprint(root_node.output)\n</code></pre>"},{"location":"user-guide/basic-usage/#multiple-roots","title":"Multiple Roots","text":"<pre><code>executor = TreeExecutor(\n    uuid=\"Multi-Root\",\n    roots=[root_a, root_b, root_c]\n)\nawait executor.run()\n# All roots start simultaneously\n</code></pre>"},{"location":"user-guide/basic-usage/#accessing-results","title":"Accessing Results","text":"<pre><code>await executor.run()\n\nresult = node.output  # Individual node output\nruntime = node.metadata.runtime  # Execution time in seconds\nlevel = node.metadata.level  # Tree depth (0 for roots)\n</code></pre>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    await executor.run()\nexcept asyncio.TimeoutError:\n    print(f\"Node timed out\")\nexcept ValueError as e:\n    print(f\"Task failed: {e}\")\n\n# Check executor errors\nif executor.errors:\n    for error in executor.errors:\n        print(f\"Error: {error}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#disconnecting-nodes","title":"Disconnecting Nodes","text":"<pre><code># Disconnect specific child\nawait parent.disconnect(child)\n\n# Redirect to new children\nawait parent.redirect([new_child_a, new_child_b])\n</code></pre>"},{"location":"user-guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Building Trees - Advanced tree structures</li> <li>Forwarding Data - State passing patterns</li> </ul>"},{"location":"user-guide/building-trees/","title":"Building Trees","text":"<p>Construct tree structures for different execution patterns.</p>"},{"location":"user-guide/building-trees/#tree-patterns","title":"Tree Patterns","text":""},{"location":"user-guide/building-trees/#linear-chain","title":"Linear Chain","text":"<p>Sequential execution:</p> <pre><code>node_1 \u2192 node_2 \u2192 node_3\n</code></pre> <pre><code>await node_1.connect(node_2, forward_as=\"data\")\nawait node_2.connect(node_3, forward_as=\"data\")\n</code></pre>"},{"location":"user-guide/building-trees/#fan-out-parallel-branches","title":"Fan-out (Parallel Branches)","text":"<p>One parent, multiple parallel children:</p> <pre><code>       root\n      / | \\\n     a  b  c\n</code></pre> <pre><code>await root.connect(child_a, forward_as=\"data\")\nawait root.connect(child_b, forward_as=\"data\")\nawait root.connect(child_c, forward_as=\"data\")\n</code></pre>"},{"location":"user-guide/building-trees/#fan-in-merge-results","title":"Fan-in (Merge Results)","text":"<p>Multiple parents converge to one child:</p> <pre><code>  a   b   c\n   \\  |  /\n      d\n</code></pre> <pre><code>await node_a.connect(merger, forward_as=\"result_a\")\nawait node_b.connect(merger, forward_as=\"result_b\")\nawait node_c.connect(merger, forward_as=\"result_c\")\n\nexecutor = TreeExecutor(roots=[node_a, node_b, node_c])\n</code></pre>"},{"location":"user-guide/building-trees/#diamond-pattern","title":"Diamond Pattern","text":"<p>Combine fan-out and fan-in:</p> <pre><code>     root\n     /  \\\n    a    b\n     \\  /\n    merger\n</code></pre> <pre><code>await root.connect(node_a, forward_as=\"data\")\nawait root.connect(node_b, forward_as=\"data\")\nawait node_a.connect(merger, forward_as=\"result_a\")\nawait node_b.connect(merger, forward_as=\"result_b\")\n</code></pre>"},{"location":"user-guide/building-trees/#multi-root-trees","title":"Multi-Root Trees","text":"<p>Independent entry points:</p> <pre><code>root_a = Node(coroutine=task_a, uuid=\"root_a\")\nroot_b = Node(coroutine=task_b, uuid=\"root_b\")\n\nexecutor = TreeExecutor(roots=[root_a, root_b])\n# Both start simultaneously\n</code></pre>"},{"location":"user-guide/building-trees/#dynamic-modification","title":"Dynamic Modification","text":""},{"location":"user-guide/building-trees/#adding-connections","title":"Adding Connections","text":"<pre><code># Add new branch during execution\nnew_node = Node(coroutine=new_task, uuid=\"new\")\nawait parent.connect(new_node)\n</code></pre>"},{"location":"user-guide/building-trees/#redirecting","title":"Redirecting","text":"<pre><code># Change children\nawait parent.redirect([new_child_a, new_child_b])\n# Old children disconnected, new ones connected\n</code></pre>"},{"location":"user-guide/building-trees/#getting-leaf-nodes","title":"Getting Leaf Nodes","text":"<pre><code>executor = TreeExecutor(roots=[root])\nleaves = executor.get_leaves()\n# Returns all nodes with no children\n</code></pre>"},{"location":"user-guide/building-trees/#next-steps","title":"Next Steps","text":"<ul> <li>Forwarding Data - Pass state between nodes</li> </ul>"},{"location":"user-guide/error-handling/","title":"Error Handling","text":"<p>Handle errors gracefully in Grafo trees.</p>"},{"location":"user-guide/error-handling/#basic-exception-handling","title":"Basic Exception Handling","text":"<p>Exceptions propagate normally:</p> <pre><code>async def failing_task():\n    raise ValueError(\"Something went wrong\")\n\nnode = Node(coroutine=failing_task, uuid=\"failer\")\nexecutor = TreeExecutor(roots=[node])\n\ntry:\n    await executor.run()\nexcept ValueError as e:\n    print(f\"Caught: {e}\")\n</code></pre>"},{"location":"user-guide/error-handling/#timeout-handling","title":"Timeout Handling","text":"<p>Set node-level timeouts:</p> <pre><code>async def slow_task():\n    await asyncio.sleep(100)\n    return \"done\"\n\nnode = Node(\n    coroutine=slow_task,\n    uuid=\"slow\",\n    timeout=5  # 5 seconds (default: 60)\n)\n\ntry:\n    await TreeExecutor(roots=[node]).run()\nexcept asyncio.TimeoutError:\n    print(f\"Timed out after 5 seconds\")\n</code></pre>"},{"location":"user-guide/error-handling/#executor-error-tracking","title":"Executor Error Tracking","text":"<p>Check accumulated errors:</p> <pre><code>executor = TreeExecutor(roots=[root])\n\ntry:\n    await executor.run()\nexcept Exception as e:\n    logger.error(f\"Execution failed: {e}\")\n\nif executor.errors:\n    for error in executor.errors:\n        print(f\"Error: {error}\")\n</code></pre>"},{"location":"user-guide/error-handling/#safe-execution-guards","title":"Safe Execution Guards","text":"<p>Grafo prevents modification of running nodes:</p> <pre><code>from grafo.errors import SafeExecutionError\n\nnode = Node(coroutine=my_task, uuid=\"task\")\nrun_task = asyncio.create_task(executor.run())\n\ntry:\n    await node.connect(new_child)  # Modification during execution\nexcept SafeExecutionError as e:\n    print(f\"Cannot modify running node: {e}\")\n\nawait run_task\n</code></pre>"},{"location":"user-guide/error-handling/#error-recovery-patterns","title":"Error Recovery Patterns","text":""},{"location":"user-guide/error-handling/#retry-pattern","title":"Retry Pattern","text":"<pre><code>async def retry_task(max_retries: int = 3):\n    for attempt in range(max_retries):\n        try:\n            return await unreliable_operation()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n            await asyncio.sleep(2 ** attempt)  # Exponential backoff\n</code></pre>"},{"location":"user-guide/error-handling/#fallback-pattern","title":"Fallback Pattern","text":"<pre><code>async def task_with_fallback():\n    try:\n        return await primary_operation()\n    except PrimaryError:\n        return await fallback_operation()\n</code></pre>"},{"location":"user-guide/error-handling/#circuit-breaker","title":"Circuit Breaker","text":"<pre><code>class CircuitBreaker:\n    def __init__(self, threshold: int = 3):\n        self.failures = 0\n        self.threshold = threshold\n        self.is_open = False\n\n    async def call(self, func):\n        if self.is_open:\n            raise Exception(\"Circuit breaker open\")\n        try:\n            result = await func()\n            self.failures = 0\n            return result\n        except Exception:\n            self.failures += 1\n            if self.failures &gt;= self.threshold:\n                self.is_open = True\n            raise\n\nbreaker = CircuitBreaker()\nnode = Node(\n    coroutine=lambda: breaker.call(unreliable_operation),\n    uuid=\"protected\"\n)\n</code></pre>"},{"location":"user-guide/error-handling/#handling-forwarding-errors","title":"Handling Forwarding Errors","text":"<p>Validate before forwarding:</p> <pre><code>async def validate_forward(parent: Node, child: Node, value: Any, required_keys: list) -&gt; Any:\n    if not isinstance(value, dict):\n        raise ValueError(f\"Invalid data from {parent.uuid}\")\n    if not all(k in value for k in required_keys):\n        raise ValueError(f\"Missing required keys: {required_keys}\")\n    return value\n\nawait parent.connect(\n    child,\n    forward_as=\"data\",\n    on_before_forward=(validate_forward, {\"required_keys\": [\"id\", \"name\"]})\n)\n</code></pre>"},{"location":"user-guide/error-handling/#error-handling-in-yielding","title":"Error Handling in Yielding","text":"<p>Collect partial results:</p> <pre><code>results = []\ntry:\n    async for item in executor.yielding():\n        if isinstance(item, Chunk):\n            results.append(item.output)\nexcept Exception as e:\n    print(f\"Error: {e}\")\n    print(f\"Collected {len(results)} results before error\")\n</code></pre>"},{"location":"user-guide/error-handling/#common-exceptions","title":"Common Exceptions","text":""},{"location":"user-guide/error-handling/#forwardingoverrideerror","title":"ForwardingOverrideError","text":"<pre><code>from grafo.errors import ForwardingOverrideError\n\nnode = Node(coroutine=consumer, kwargs=dict(value=\"preset\"))\ntry:\n    await parent.connect(node, forward_as=\"value\")\nexcept ForwardingOverrideError:\n    # Can't override existing kwarg\n    pass\n</code></pre>"},{"location":"user-guide/error-handling/#mismatchchunktype","title":"MismatchChunkType","text":"<pre><code>from grafo.errors import MismatchChunkType\n\nnode = Node[str](coroutine=returns_int, uuid=\"wrong\")\ntry:\n    await TreeExecutor(roots=[node]).run()\nexcept MismatchChunkType as e:\n    print(f\"Type mismatch: {e}\")\n</code></pre>"},{"location":"user-guide/error-handling/#notasynccallableerror","title":"NotAsyncCallableError","text":"<pre><code>from grafo.errors import NotAsyncCallableError\n\nnode = Node(coroutine=regular_coroutine, uuid=\"regular\")\ntry:\n    await node.run_yielding()  # Wrong method\nexcept NotAsyncCallableError:\n    # Use run() instead\n    await node.run()\n</code></pre>"},{"location":"user-guide/error-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Fail fast for logic errors: Don't catch programming mistakes</li> <li>Log with context: Include node UUIDs and details</li> <li>Handle expected errors: Retry transient failures</li> <li>Clean up resources: Use try/finally for cleanup</li> <li>Document exceptions: Note what can be raised</li> </ol>"},{"location":"user-guide/error-handling/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - All exception types</li> <li>Event Callbacks - Monitor errors</li> </ul>"},{"location":"user-guide/event-callbacks/","title":"Event Callbacks","text":"<p>Hook into node lifecycle events for monitoring, logging, and custom behaviors.</p>"},{"location":"user-guide/event-callbacks/#overview","title":"Overview","text":"<p>Grafo provides callbacks at key lifecycle points:</p> <ul> <li><code>on_connect</code> - When a node connects to a child</li> <li><code>on_disconnect</code> - When a node disconnects from a child</li> <li><code>on_before_run</code> - Before node execution</li> <li><code>on_after_run</code> - After node execution</li> <li><code>on_before_forward</code> - Before forwarding data (during <code>connect()</code>)</li> </ul> <p>Callbacks are tuples of <code>(async_function, kwargs_dict)</code>. The kwargs dict can contain lambdas for dynamic evaluation.</p>"},{"location":"user-guide/event-callbacks/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/event-callbacks/#simple-callbacks","title":"Simple Callbacks","text":"<pre><code>async def log_start(node: Node):\n    print(f\"Starting {node.uuid}\")\n\nasync def log_complete(node: Node):\n    print(f\"Completed {node.uuid} in {node.metadata.runtime}s\")\n\nnode = Node(\n    coroutine=my_task,\n    uuid=\"task\",\n    on_before_run=(log_start, {}),\n    on_after_run=(log_complete, {})\n)\n</code></pre>"},{"location":"user-guide/event-callbacks/#callbacks-with-arguments","title":"Callbacks with Arguments","text":"<p>Pass additional arguments via kwargs dict:</p> <pre><code>async def log_with_level(node: Node, level: str, prefix: str):\n    print(f\"[{level}] {prefix}: {node.uuid}\")\n\nnode = Node(\n    coroutine=my_task,\n    uuid=\"task\",\n    on_before_run=(log_with_level, {\"level\": \"INFO\", \"prefix\": \"START\"}),\n    on_after_run=(log_with_level, {\"level\": \"INFO\", \"prefix\": \"DONE\"})\n)\n</code></pre>"},{"location":"user-guide/event-callbacks/#callback-signatures","title":"Callback Signatures","text":""},{"location":"user-guide/event-callbacks/#on_connect-on_disconnect","title":"on_connect / on_disconnect","text":"<pre><code>async def connection_callback(parent: Node, child: Node, **kwargs):\n    print(f\"{parent.uuid} \u2192 {child.uuid}\")\n\nnode = Node(\n    coroutine=my_task,\n    uuid=\"parent\",\n    on_connect=(connection_callback, {\"log_level\": \"DEBUG\"})\n)\n</code></pre>"},{"location":"user-guide/event-callbacks/#on_before_run-on_after_run","title":"on_before_run / on_after_run","text":"<pre><code>async def execution_callback(node: Node, **kwargs):\n    print(f\"Node: {node.uuid}\")\n\nnode = Node(\n    coroutine=my_task,\n    uuid=\"task\",\n    on_before_run=(execution_callback, {\"stage\": \"pre\"}),\n    on_after_run=(execution_callback, {\"stage\": \"post\"})\n)\n</code></pre>"},{"location":"user-guide/event-callbacks/#on_before_forward","title":"on_before_forward","text":"<p>Passed during <code>connect()</code>, can transform forwarded values:</p> <pre><code>async def transform_forward(parent: Node, child: Node, value: Any, **kwargs) -&gt; Any:\n    multiplier = kwargs.get(\"multiplier\", 1)\n    return value * multiplier\n\nawait parent.connect(\n    child,\n    forward_as=\"data\",\n    on_before_forward=(transform_forward, {\"multiplier\": 2})\n)\n</code></pre>"},{"location":"user-guide/event-callbacks/#using-lambdas-in-callback-kwargs","title":"Using Lambdas in Callback Kwargs","text":"<p>The kwargs dict can contain lambdas for dynamic evaluation:</p> <pre><code>async def log_with_context(node: Node, parent_output: str, custom_msg: str):\n    print(f\"{custom_msg}: {node.uuid} received {parent_output}\")\n\nparent_node = Node(coroutine=parent_task, uuid=\"parent\")\nchild_node = Node(\n    coroutine=child_task,\n    uuid=\"child\",\n    on_before_run=(log_with_context, {\n        \"parent_output\": lambda: parent_node.output,  # Evaluated at runtime\n        \"custom_msg\": \"Processing\"\n    })\n)\n\nawait parent_node.connect(child_node)\n</code></pre>"},{"location":"user-guide/event-callbacks/#error-handling-in-callbacks","title":"Error Handling in Callbacks","text":"<p>Callbacks should handle their own errors:</p> <pre><code>async def safe_callback(node: Node, retry_count: int):\n    try:\n        await risky_operation(node)\n    except Exception as e:\n        logger.error(f\"Callback error: {e}\")\n        # Don't re-raise - don't disrupt execution\n\nnode = Node(\n    coroutine=my_task,\n    uuid=\"task\",\n    on_after_run=(safe_callback, {\"retry_count\": 3})\n)\n</code></pre>"},{"location":"user-guide/event-callbacks/#next-steps","title":"Next Steps","text":"<ul> <li>Error Handling - Robust error management</li> <li>API Reference - Complete callback documentation</li> </ul>"},{"location":"user-guide/forwarding-data/","title":"Forwarding Data","text":"<p>Pass state between nodes using automatic or manual forwarding.</p>"},{"location":"user-guide/forwarding-data/#automatic-forwarding","title":"Automatic Forwarding","text":"<p>Specify parameter mapping when connecting:</p> <pre><code>async def producer():\n    return \"data\"\n\nasync def consumer(input_data: str):\n    return f\"processed_{input_data}\"\n\nnode_a = Node(coroutine=producer, uuid=\"producer\")\nnode_b = Node(coroutine=consumer, uuid=\"consumer\")\n\n# Forward node_a's output to node_b's 'input_data' parameter\nawait node_a.connect(node_b, forward_as=\"input_data\")\n</code></pre>"},{"location":"user-guide/forwarding-data/#multiple-parents","title":"Multiple Parents","text":"<p>Each parent forwards to different parameters:</p> <pre><code>async def get_name():\n    return \"alice\"\n\nasync def get_age():\n    return 30\n\nasync def create_profile(name: str, age: int):\n    return {\"name\": name, \"age\": age}\n\nname_node = Node(coroutine=get_name, uuid=\"name\")\nage_node = Node(coroutine=get_age, uuid=\"age\")\nprofile_node = Node(coroutine=create_profile, uuid=\"profile\")\n\nawait name_node.connect(profile_node, forward_as=\"name\")\nawait age_node.connect(profile_node, forward_as=\"age\")\n</code></pre>"},{"location":"user-guide/forwarding-data/#manual-forwarding","title":"Manual Forwarding","text":"<p>Use lambdas for dynamic evaluation:</p> <pre><code>node_b = Node(\n    coroutine=consumer,\n    uuid=\"consumer\",\n    kwargs=dict(\n        value=lambda: node_a.output  # Evaluated when node_b runs\n    )\n)\n\nawait node_a.connect(node_b)\n</code></pre>"},{"location":"user-guide/forwarding-data/#transformation","title":"Transformation","text":"<p>Transform data before passing:</p> <pre><code>kwargs=dict(\n    value=lambda: node_a.output.upper()  # Transform to uppercase\n)\n</code></pre>"},{"location":"user-guide/forwarding-data/#extraction","title":"Extraction","text":"<p>Extract part of parent's output:</p> <pre><code>kwargs=dict(\n    name=lambda: node_a.output[\"name\"]  # Extract just name field\n)\n</code></pre>"},{"location":"user-guide/forwarding-data/#combination","title":"Combination","text":"<p>Combine multiple parent outputs:</p> <pre><code>kwargs=dict(\n    combined=lambda: f\"{node_a.output} + {node_b.output}\"\n)\n</code></pre>"},{"location":"user-guide/forwarding-data/#forwarding-with-transformations","title":"Forwarding with Transformations","text":"<p>Use <code>on_before_forward</code> callback:</p> <pre><code>async def transform(parent: Node, child: Node, value: Any, **kwargs) -&gt; Any:\n    return value.upper()\n\nawait parent.connect(\n    child,\n    forward_as=\"data\",\n    on_before_forward=(transform, {})\n)\n</code></pre> <p>The kwargs dict can contain lambdas:</p> <pre><code>async def scale_value(parent: Node, child: Node, value: Any, multiplier: int) -&gt; Any:\n    return value * multiplier\n\nawait parent.connect(\n    child,\n    forward_as=\"data\",\n    on_before_forward=(scale_value, {\"multiplier\": lambda: some_node.output})\n)\n</code></pre>"},{"location":"user-guide/forwarding-data/#constraints","title":"Constraints","text":""},{"location":"user-guide/forwarding-data/#no-override-conflicts","title":"No Override Conflicts","text":"<p>Can't forward to pre-set parameters:</p> <pre><code># This raises ForwardingOverrideError\nchild = Node(coroutine=task, kwargs=dict(value=\"preset\"))\nawait parent.connect(child, forward_as=\"value\")  # Error!\n\n# Solution: use different parameter or remove preset\n</code></pre>"},{"location":"user-guide/forwarding-data/#parameter-must-exist","title":"Parameter Must Exist","text":"<p>Forwarding parameter must match coroutine signature:</p> <pre><code>async def consumer(expected_param: str):\n    return expected_param\n\n# Correct\nawait parent.connect(child, forward_as=\"expected_param\")\n\n# Wrong - raises error\nawait parent.connect(child, forward_as=\"wrong_param\")\n</code></pre>"},{"location":"user-guide/forwarding-data/#aggregating-child-outputs","title":"Aggregating Child Outputs","text":"<p>Access all child outputs from parent:</p> <pre><code>await parent.connect(child_a, forward_as=\"data\")\nawait parent.connect(child_b, forward_as=\"data\")\nawait parent.connect(child_c, forward_as=\"data\")\n\nawait executor.run()\n\noutputs = parent.aggregated_output  # List of all child outputs\n</code></pre>"},{"location":"user-guide/forwarding-data/#next-steps","title":"Next Steps","text":"<ul> <li>Yielding Results - Stream intermediate results</li> <li>Type Validation - Ensure type safety</li> </ul>"},{"location":"user-guide/type-validation/","title":"Type Validation","text":"<p>Runtime type validation using Python generics.</p>"},{"location":"user-guide/type-validation/#basic-type-validation","title":"Basic Type Validation","text":"<p>Specify expected return type:</p> <pre><code>from grafo import Node\n\nasync def return_string():\n    return \"text\"\n\nasync def return_number():\n    return 42\n\n# Type-validated nodes\nstring_node = Node[str](coroutine=return_string, uuid=\"string\")\nnumber_node = Node[int](coroutine=return_number, uuid=\"number\")\n</code></pre>"},{"location":"user-guide/type-validation/#type-checking","title":"Type Checking","text":"<p>Raises <code>MismatchChunkType</code> on type mismatch:</p> <pre><code>async def wrong_type():\n    return 42  # Returns int\n\nnode = Node[str](coroutine=wrong_type, uuid=\"wrong\")  # Expects str\n\ntry:\n    await TreeExecutor(roots=[node]).run()\nexcept MismatchChunkType as e:\n    print(f\"Type error: {e}\")\n</code></pre>"},{"location":"user-guide/type-validation/#validation-for-yielded-values","title":"Validation for Yielded Values","text":"<p>All yields must match the type:</p> <pre><code>async def yield_strings():\n    yield \"first\"\n    yield \"second\"\n    yield \"third\"\n\nnode = Node[str](coroutine=yield_strings, uuid=\"yielder\")\n# All yields validated\n</code></pre>"},{"location":"user-guide/type-validation/#complex-types","title":"Complex Types","text":""},{"location":"user-guide/type-validation/#collections","title":"Collections","text":"<pre><code>async def return_list():\n    return [1, 2, 3]\n\nasync def return_dict():\n    return {\"key\": \"value\"}\n\nlist_node = Node[list](coroutine=return_list, uuid=\"list\")\ndict_node = Node[dict](coroutine=return_dict, uuid=\"dict\")\n</code></pre>"},{"location":"user-guide/type-validation/#custom-classes","title":"Custom Classes","text":"<pre><code>class UserData:\n    def __init__(self, name: str):\n        self.name = name\n\nasync def return_user():\n    return UserData(\"Alice\")\n\nuser_node = Node[UserData](coroutine=return_user, uuid=\"user\")\n</code></pre>"},{"location":"user-guide/type-validation/#optional-types","title":"Optional Types","text":"<p>Handle None values:</p> <pre><code>from typing import Optional\n\nasync def maybe_return():\n    return None  # or \"value\"\n\nnode = Node[Optional[str]](coroutine=maybe_return, uuid=\"maybe\")\n</code></pre>"},{"location":"user-guide/type-validation/#union-types","title":"Union Types","text":"<pre><code>from typing import Union\n\nasync def return_str_or_int():\n    return \"string\"  # or 42\n\nnode = Node[Union[str, int]](coroutine=return_str_or_int, uuid=\"union\")\n</code></pre>"},{"location":"user-guide/type-validation/#without-type-validation","title":"Without Type Validation","text":"<p>Omit type parameter for no validation:</p> <pre><code>node = Node(coroutine=any_return_type, uuid=\"untyped\")\n# No runtime validation\n</code></pre>"},{"location":"user-guide/type-validation/#type-hints-vs-grafo-generics","title":"Type Hints vs Grafo Generics","text":"<pre><code># Type hint (static checking with mypy)\nasync def typed_function() -&gt; str:\n    return \"result\"\n\n# Grafo generic (runtime validation)\nnode = Node[str](coroutine=typed_function, uuid=\"node\")\n\n# Use both for maximum safety\n</code></pre>"},{"location":"user-guide/type-validation/#when-to-use","title":"When to Use","text":"<p>Use type validation for: - Critical data flows - API contracts - Complex pipelines - Integration points</p> <p>Skip for: - Prototyping - Dynamic types - Performance-critical paths</p>"},{"location":"user-guide/type-validation/#next-steps","title":"Next Steps","text":"<ul> <li>Event Callbacks - Hook into node lifecycle</li> <li>Error Handling - Handle type errors</li> </ul>"},{"location":"user-guide/yielding-results/","title":"Yielding Results","text":"<p>Stream intermediate results from long-running tasks using async generators.</p>"},{"location":"user-guide/yielding-results/#overview","title":"Overview","text":"<p>Async generators yield intermediate values wrapped in <code>Chunk</code> objects containing: - <code>uuid</code>: Source node UUID - <code>output</code>: The yielded value</p>"},{"location":"user-guide/yielding-results/#basic-yielding","title":"Basic Yielding","text":"<pre><code>from grafo import Node, TreeExecutor, Chunk\n\nasync def counting_task():\n    for i in range(5):\n        yield f\"Step {i}\"\n\nnode = Node(coroutine=counting_task, uuid=\"counter\")\nexecutor = TreeExecutor(roots=[node])\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        print(f\"[{item.uuid}] {item.output}\")\n    elif isinstance(item, Node):\n        print(f\"Completed: {item.uuid}\")\n</code></pre>"},{"location":"user-guide/yielding-results/#yielding-vs-regular-execution","title":"Yielding vs Regular Execution","text":""},{"location":"user-guide/yielding-results/#regular-run","title":"Regular (<code>run()</code>)","text":"<p>Waits for all nodes, returns everything at once:</p> <pre><code>nodes, chunks = await executor.run()\n# All chunks returned after completion\n</code></pre>"},{"location":"user-guide/yielding-results/#yielding-yielding","title":"Yielding (<code>yielding()</code>)","text":"<p>Streams results as they arrive:</p> <pre><code>async for item in executor.yielding():\n    # Process results in real-time\n    pass\n</code></pre>"},{"location":"user-guide/yielding-results/#multiple-yielding-nodes","title":"Multiple Yielding Nodes","text":"<p>Results arrive interleaved from parallel nodes:</p> <pre><code>async def task_a():\n    for i in range(3):\n        yield f\"A{i}\"\n\nasync def task_b():\n    for i in range(3):\n        yield f\"B{i}\"\n\nnode_a = Node(coroutine=task_a, uuid=\"a\")\nnode_b = Node(coroutine=task_b, uuid=\"b\")\n\nexecutor = TreeExecutor(roots=[node_a, node_b])\n\nasync for item in executor.yielding():\n    if isinstance(item, Chunk):\n        print(item.output)  # A0, B0, A1, B1, A2, B2 (interleaved)\n</code></pre>"},{"location":"user-guide/yielding-results/#latency-control","title":"Latency Control","text":"<p>Adjust check frequency:</p> <pre><code>async for item in executor.yielding(latency=0.1):  # Check every 100ms\n    pass\n\n# Lower latency = more responsive, higher CPU\n# Higher latency = less CPU, slower response\n# Default: 0.2 (200ms)\n</code></pre>"},{"location":"user-guide/yielding-results/#type-validation","title":"Type Validation","text":"<p>Validate yielded types:</p> <pre><code>async def yield_strings():\n    yield \"first\"\n    yield \"second\"\n\nnode = Node[str](coroutine=yield_strings, uuid=\"typed\")\n# Raises MismatchChunkType if any yield is not a string\n</code></pre>"},{"location":"user-guide/yielding-results/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/yielding-results/#partial-results","title":"Partial Results","text":"<p>Collect results before error:</p> <pre><code>results = []\ntry:\n    async for item in executor.yielding():\n        if isinstance(item, Chunk):\n            results.append(item.output)\nexcept Exception as e:\n    print(f\"Error: {e}\")\n    print(f\"Collected {len(results)} results before error\")\n</code></pre>"},{"location":"user-guide/yielding-results/#mixing-yielding-and-regular-nodes","title":"Mixing Yielding and Regular Nodes","text":"<p>Trees can contain both types:</p> <pre><code>async def regular_task():\n    return \"regular result\"\n\nasync def yielding_task():\n    yield \"step 1\"\n    yield \"step 2\"\n\n# Both work in same tree\n</code></pre>"},{"location":"user-guide/yielding-results/#next-steps","title":"Next Steps","text":"<ul> <li>Type Validation - Validate yielded types</li> <li>Event Callbacks - Monitor progress</li> </ul>"}]}